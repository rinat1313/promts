#1. КОНТЕКСТ 
Сейчас добавленна структура объекта:
/type CommandType string

 const (
 	CmdCreate   CommandType = "создание"
 	CmdDelete   CommandType = "удаление"
 	CmdEdit     CommandType = "внесение изменений"
 	CmdCopy     CommandType = "копирование"
 	CmdMove     CommandType = "перемещение"
 	CmdRead     CommandType = "чтение"
 	CmdAddLines CommandType = "добавление строк"
 	CmdDeleteLines    CommandType = "удаление строк"
 	CmdCompileCode	CommandType = "компиляция"

 )

 // Command представляет одну атомарную команду для модификации файловой системы.
 type Command struct {
 	Type    CommandType
 	Path    string         // основной путь к файлу
 	Content string         // полный контент файла (для создания)
 	Lines   map[int]string // изменения по номерам строк (для редактирования)
 	SrcPath string         // исходный путь (копирование/перемещение)
 	DstPath string         // целевой путь (копирование/перемещение)
 }


 реализована функция для запуска процесса проверки компиляции
 package compiler

 import (
 	"bytes"
 	"errors"
 	"os/exec"
 	"path/filepath"
 	"runtime"
 	"strings"
 )

 // Compile выполняет компиляцию Go-кода по указанному пути (файл или директория проекта)
 // после применения атомарных команд Command. Использует go build для выявления
 // максимального количества критических ошибок компиляции (синтаксис, типы,
 // неиспользуемые идентификаторы и т.д.).
 func Compile(path string) (string, error) {
 	// Определяем рабочую директорию
 	dir := filepath.Dir(path)
 	if dir == "." || dir == "" || dir == "/" {
 		dir = path
 	}

 	// Кросс-платформенный путь к /dev/null
 	devNull := "/dev/null"
 	if runtime.GOOS == "windows" {
 		devNull = "NUL"
 	}

 	// Формируем аргументы: для .go-файла собираем только его,
 	// иначе весь пакет и подпакеты
 	args := []string{"build", "-o", devNull, "./..."}
 	if strings.HasSuffix(strings.ToLower(path), ".go") {
 		args = []string{"build", "-o", devNull, path}
 	}

 	cmd := exec.Command("go", args...)
 	cmd.Dir = dir

 	// Захватываем весь вывод (stdout + stderr)
 	output, err := cmd.CombinedOutput()

 	if err != nil {
 		compileLog := string(output)
 		if compileLog == "" {
 			compileLog = err.Error()
 		}
 		return compileLog, errors.New("Ошибка компиляции.")
 	}

 	return "", nil
 }


 ранее реализованный код по исполнению полученных команд:
 package service

 import (
 	"Ralf/domen"
 	"errors"
 	"fmt"
 	"os"
 	"path/filepath"
 	"sort"
 	"strings"
 )

 // ExecuteCommand выполняет переданную команду.
 // Возвращает содержимое файла только для CmdRead, иначе пустую строку.
 func ExecuteCommand(cmd domen.Command) (string, error) {
 	switch cmd.Type {
 	case domen.CmdCreate:
 		return "", executeCreate(cmd)
 	case domen.CmdDelete:
 		return "", executeDelete(cmd)
 	case domen.CmdEdit:
 		return "", executeEdit(cmd)
 	case domen.CmdAddLines:
 		return "", executeAddLines(cmd)
 	case domen.CmdDeleteLines:
 		return "", executeDeleteLines(cmd)
 	case domen.CmdCopy:
 		return "", executeCopy(cmd)
 	case domen.CmdMove:
 		return "", executeMove(cmd)
 	case domen.CmdRead:
 		return executeRead(cmd)
 	default:
 		return "", fmt.Errorf("неизвестный тип команды: %s", cmd.Type)
 	}
 }

 func fileExists(path string) bool {
 	_, err := os.Stat(path)
 	return !os.IsNotExist(err)
 }

 func readLines(path string) ([]string, error) {
 	data, err := os.ReadFile(path)
 	if err != nil {
 		return nil, err
 	}
 	content := string(data)
 	lines := strings.Split(content, "\n")
 	if len(lines) > 0 && lines[len(lines)-1] == "" {
 		lines = lines[:len(lines)-1]
 	}
 	return lines, nil
 }

 func writeLines(path string, lines []string) error {
 	content := strings.Join(lines, "\n")
 	if len(lines) > 0 {
 		content += "\n"
 	}
 	return os.WriteFile(path, []byte(content), 0644)
 }

 func executeCreate(cmd domen.Command) error {
 	if fileExists(cmd.Path) {
 		return fmt.Errorf("файл уже существует: %s", cmd.Path)
 	}
 	if cmd.Content == "" {
 		return errors.New("пустое содержимое для создания файла")
 	}
 	if dir := filepath.Dir(cmd.Path); dir != "." && dir != "" {
 		if err := os.MkdirAll(dir, 0755); err != nil {
 			return fmt.Errorf("не удалось создать директорию: %w", err)
 		}
 	}
 	return os.WriteFile(cmd.Path, []byte(cmd.Content), 0644)
 }

 func executeDelete(cmd domen.Command) error {
 	if !fileExists(cmd.Path) {
 		return fmt.Errorf("файл не существует: %s", cmd.Path)
 	}
 	return os.Remove(cmd.Path)
 }

 func executeEdit(cmd domen.Command) error {
 	if !fileExists(cmd.Path) {
 		return fmt.Errorf("файл не существует: %s", cmd.Path)
 	}
 	if len(cmd.Lines) == 0 {
 		return errors.New("нет строк для изменения")
 	}
 	lines, err := readLines(cmd.Path)
 	if err != nil {
 		return fmt.Errorf("не удалось прочитать файл %s: %w", cmd.Path, err)
 	}
 	for lineNum, newText := range cmd.Lines {
 		if lineNum < 1 || lineNum > len(lines) {
 			return fmt.Errorf("строка %d не существует в файле %s (всего строк: %d)", lineNum, cmd.Path, len(lines))
 		}
 		lines[lineNum-1] = newText
 	}
 	return writeLines(cmd.Path, lines)
 }

 func executeAddLines(cmd domen.Command) error {
 	if !fileExists(cmd.Path) {
 		return fmt.Errorf("файл не существует: %s", cmd.Path)
 	}
 	if len(cmd.Lines) == 0 {
 		return errors.New("нет строк для добавления")
 	}
 	lines, err := readLines(cmd.Path)
 	if err != nil {
 		return fmt.Errorf("не удалось прочитать файл %s: %w", cmd.Path, err)
 	}
 	currentLen := len(lines)
 	keys := make([]int, 0, len(cmd.Lines))
 	for k := range cmd.Lines {
 		keys = append(keys, k)
 	}
 	sort.Ints(keys)
 	if keys[0] != currentLen+1 {
 		return fmt.Errorf("нельзя добавить строку %d: файл содержит только %d строк", keys[0], currentLen)
 	}
 	for i := 1; i < len(keys); i++ {
 		if keys[i] != keys[i-1]+1 {
 			return errors.New("строки для добавления должны идти последовательно без пропусков")
 		}
 	}
 	for _, k := range keys {
 		lines = append(lines, cmd.Lines[k])
 	}
 	return writeLines(cmd.Path, lines)
 }

 func executeDeleteLines(cmd domen.Command) error {
 	if !fileExists(cmd.Path) {
 		return fmt.Errorf("файл не существует: %s", cmd.Path)
 	}
 	if len(cmd.Lines) == 0 {
 		return errors.New("нет строк для удаления")
 	}
 	lines, err := readLines(cmd.Path)
 	if err != nil {
 		return fmt.Errorf("не удалось прочитать файл %s: %w", cmd.Path, err)
 	}
 	keys := make([]int, 0, len(cmd.Lines))
 	for k := range cmd.Lines {
 		keys = append(keys, k)
 	}
 	sort.Sort(sort.Reverse(sort.IntSlice(keys))) // удаляем с большей строки к меньшей
 	for _, k := range keys {
 		if k < 1 || k > len(lines) {
 			return fmt.Errorf("строка %d не существует в файле %s (всего строк: %d)", k, cmd.Path, len(lines))
 		}
 		idx := k - 1
 		lines = append(lines[:idx], lines[idx+1:]...)
 	}
 	return writeLines(cmd.Path, lines)
 }

 func executeCopy(cmd domen.Command) error {
 	if cmd.SrcPath == "" || cmd.DstPath == "" {
 		return errors.New("не указаны пути для копирования")
 	}
 	if !fileExists(cmd.SrcPath) {
 		return fmt.Errorf("исходный файл не существует: %s", cmd.SrcPath)
 	}
 	if fileExists(cmd.DstPath) {
 		return fmt.Errorf("целевой файл уже существует: %s", cmd.DstPath)
 	}
 	if dir := filepath.Dir(cmd.DstPath); dir != "." && dir != "" {
 		if err := os.MkdirAll(dir, 0755); err != nil {
 			return fmt.Errorf("не удалось создать директорию: %w", err)
 		}
 	}
 	data, err := os.ReadFile(cmd.SrcPath)
 	if err != nil {
 		return fmt.Errorf("не удалось прочитать исходный файл: %w", err)
 	}
 	return os.WriteFile(cmd.DstPath, data, 0644)
 }

 func executeMove(cmd domen.Command) error {
 	if cmd.SrcPath == "" || cmd.DstPath == "" {
 		return errors.New("не указаны пути для перемещения")
 	}
 	if !fileExists(cmd.SrcPath) {
 		return fmt.Errorf("исходный файл не существует: %s", cmd.SrcPath)
 	}
 	if fileExists(cmd.DstPath) {
 		return fmt.Errorf("целевой файл уже существует: %s", cmd.DstPath)
 	}
 	if dir := filepath.Dir(cmd.DstPath); dir != "." && dir != "" {
 		if err := os.MkdirAll(dir, 0755); err != nil {
 			return fmt.Errorf("не удалось создать директорию: %w", err)
 		}
 	}
 	return os.Rename(cmd.SrcPath, cmd.DstPath)
 }

 func executeRead(cmd domen.Command) (string, error) {
 	if !fileExists(cmd.Path) {
 		return "", fmt.Errorf("файл не существует: %s", cmd.Path)
 	}
 	data, err := os.ReadFile(cmd.Path)
 	if err != nil {
 		return "", fmt.Errorf("не удалось прочитать файл %s: %w", cmd.Path, err)
 	}
 	return string(data), nil
 }


#2. ЦЕЛЬ 
Создать метод который получает структуру Command и делает то что указано в этой команде.
Просто добавь код который связан с компиляцией.
#3. ДЕТАЛИ
При выполнении задачи обязательно учти следующие нюансы:
1) Обязательно надо описать в конце почему ты написал такой код.
2) Надо реализовать механизм выполнения команд.
3) При команде создания функция должна убедится что такого файла нет и создать файл который указан в Path, возвращаем error если не получилось.
4) При команде удаления функция должна убедится что такой файл есть и удалить файл который указан в Path, возвращаем error если не получилось.
5) При команде внесение изменений должна убедится что такой файл есть и есть строки которые надо изменить (к примеру надо внести изменения в строку 20, хотя строк в файле 15, то мы не должны вносить изменения и надо вывести ошибку)
и внести изменения в файл согласно данным по строкам которые хранятся в Lines, возвращаем error если не получилось.
6) При команде копирование должна убедится что такой файл есть и в место куда мы копируем там нету файла с таким же именем и разрешением и далее проводим операцию копирования файла, возвращаем error если не получилось.
7) При команде перемещения должна убедится что такой файл есть и в место куда мы копируем там нету файла с таким же именем и разрешением и далее проводим операцию перемещения файла, возвращаем error если не получилось.
8) При команде чтение должна убедится что такой файл есть и далее проводим операцию чтения файла, возвращаем error если не получилось и сам текст который есть в файле, но важный момент надо сохранять данные по строчно, что бы потом
мы могли вносить изменения точечно по строчно.
9) При команде добавление строк должна убедится что такой файл есть и далее проводим операцию чтения файла и проверяем возможность добавления строк если их нет (к примеру не можем добавить строку 10, если в файле строк только 5)
, возвращаем error если не получилось.
10) При команде удаление строк должна убедится что такой файл есть и далее проводим операцию чтения файла и проверяем возможность удаления строк если их нет (к примеру не можем удалить строку то возвращаем ошибку)
, возвращаем error если не получилось.
11) При команде компиляция убедится что такой файл есть и произвести компиляцию данного файла, при этом используем указанный адрес в Path, при получении ошибки надо подготовить запрос для lm studio, если ошибки нет то всё хорошо.
#4. ФОРМАТ ВЫВОДА
Ответ оформи строго по этим требованиям:
1) Сначала идёт код в Go.
2) В конце идёт txt файл где описано почему написан именно такой код.
3) Объём без ограничений.
#5. ПРИМЕРЫ (FEW-SHOT) 
Мне нужен ответ, похожий на этот пример:
приблизительный пример:
полученная команда:
command:
type: cmdDelete;
path: "/test_file.txt"

что происходит:
удаляется файл по адресу /test_file.txt

полученная команда:
command:
type: cmdEdit;
path: "/test_file.txt"
lines[2]
{
10:"New text",
255:"fmt.Println("Hello world")
}

что происходит:
в файле /test_file.txt
на строке 10 внесены изменения на текст "New text"
на строке 255 внесены изменения на текст "fmt.Println("Hello world")

полученная команда:
command:
type: CmdAddLines;
path: "/test_file.txt"
lines[2]
{
10:"New text",
11:"fmt.Println("Hello world")
}

что происходит:
в файле /test_file.txt
в файл добавляется строка 10 с текстом "New text"
в файл добавляется строка 11 с текстом "fmt.Println("Hello world")

полученная команда:
command:
type: CmdDeleteLines;
path: "/test_file.txt"
deleteLines[2]
{
10,15
}

что происходит:
в файле /test_file.txt
удаляем с большей цифры строки к меньшей.

Сделай так же с моими данными.

#6. ОГРАНИЧЕНИЯ 
В ответе НЕ используй:
- Воду и общие фразы.
- Ничего кроме кода Go и комментария в нём и txt файла с описанием почему такой код был выбран ничего больше не должно быть.